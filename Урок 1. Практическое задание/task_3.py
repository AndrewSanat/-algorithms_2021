"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
import time
# Зададим словарь с перечнем компаний и размеров их прибыли:
profits = {
    'GAZ': 246867768,
    'VAZ': 3578676547653,
    'MAZ': 13454256,
    'ZAZ': 3114625887,
    'UAZ': 314635465,
    'KAMAZ': 234324565453546,
    'URAL': 314635465247569999,
    'LIAZ': 314635465,
    'NEFAZ': 23432456,
}

# for k, v in profits.items():
#     if v in max_profits:
#         print(k)


# Алгоритм №1:
"""
Возвращает наименования компаний (ключи словаря) если значения прибыли есть в списке значений.
Сам список значений формируется встроенной командой sorted с использованием реверса, а затем срезом 
оставляем три первых значения, которые как раз являются максимальными.
"""
# Сложность = O(n * log(n)) + O(n^2) = O(n^2)
def greatest_profits_1(dict):
    start_val = time.time()
    max_profits = sorted(dict.values(), reverse=True)[:3] # O(n * log(n)) - максимальная сложность от команды sorted()
    return [k for k, v in dict.items() if v in max_profits] # O(n^2) если не учитывать, что в списке только 3 значения


print(f'Результат работы алгоритма №1: {greatest_profits_1(profits)}')


# Алгоритм №2:
"""
Возвращает наименования компаний (ключи словаря) если значения прибыли есть в списке значений.
Сам список значений формируется функцией "сортировки выбором", а затем срезом 
оставляем три первых значения, которые как раз являются максимальными.
Отличается от алгоритма №1 только способом сортировки.
"""
# Сложность = O(n^2) + O(n^2) = O(2 * n^2) = O(n^2)
def greatest_profits_2(dict):
    max_profits = sort_from_largest(list(dict.values()))[:3]
    return [k for k, v in dict.items() if v in max_profits]


def find_largest(lst): # Сложность O(n) за счёт цикла for
    largest = lst[0]
    largest_index = 0
    for i in range(1, len(lst)):
        if lst[i] > largest:
            largest = lst[i]
            largest_index = i
    return largest_index


def sort_from_largest(lst): # Сложность = O(n^2) за счёт собственного цикла и встроенного в него вывоза функции с O(n)
    sorted_list = []
    for i in range(len(lst)):
        largest = find_largest(lst)
        sorted_list.append(lst.pop(largest))
    return sorted_list


print(f'Результат работы алгоритма №2: {greatest_profits_2(profits)}')

'''
Вывод:
Несмотря на то, что итоговая сложность существенно свелась к равенству, первый алгоритм считаю более оптимальным,
так как в нём задействована более оптимальная функция сортировки, меньше переменных. Да и дальнейшая поддержка кода
в первом варианте существенно проще.
'''
